//     processor.js Component object model library
//     (c) 2013 vadim b. https://github.com/aplib/processor.js
//     license: MIT

(function() { 'use strict';
    // const*

    // required
    var emitter = require('events').EventEmitter;

    var processor = {
        VERSION: '0.1.08'/*#.#.##*/,
        id_generator: 1792,
        subtypes: {},   // Registered subtypes
    
        /**
         * Component initialization. Initialize component attributes ```parameters, arguments, parent, childs``` etc. Normally called from the constructor function of the component.
         *
         * @param {object} object Object to be initialized.
         * @param {string} __type Base type of the component. This value is assigned to the attribute __type of the component.
         * @param {object} parameters Hash object contains parsed parameters of the component.
         * @param {object} args Hash object contains arguments of the component.
         * @returns {object} Returns this.
         */
        componentInitialize: function(object, __type, parameters, args) {

            if (parameters) {
                object.id = parameters.id || (parameters.id = (processor.id_generator++).toString(16)); // set per session uid
                object.name = parameters.name;
                
                // default prime binds
                if ('' in args) {
                    var prime = args[''];
                    if (prime instanceof DataArray || prime instanceof DataObject)
                        this.bind(prime);
                }
                object.parameters = parameters;
            } else {
                object.parameters = {id:(object.id = (parameters.id = (processor.id_generator++).toString(16)))}; // set per session uid
            }
            
            if (!__type)
                throw new TypeError('Invalid node type!');
            
            object.__type   = (__type.indexOf('.') < 0) ? ('default.' + __type) : __type;
            object.arguments = args || {};
            object.state = Number.MIN_VALUE;        // State id
            object.childs = [];                     // Child nodes collection
            object.onparent_reflected = 0;          // On parent reflected state
            object.in = [];
            object.in_reflected = [];
            object.out = [];
            object.out_reflected = [];

            return object;
        },
    
        /**
         * Register constructor function in the processor library
         * 
         * @param {string} type Type string can include namespace, type and optional parameters.
         * @param {function} constructor Object constructor function.
         * @returns {undefined} no returns value
         */
        typeRegister: function(type, constructor) {
            this.factoryRegister(type, constructor);
            constructor.is_constructor = true;
        },
    
        /**
         * Register factory function in the processor library
         * 
         * @param {string} type Type string can include namespace, type and optional parameters.
         * @param {function} factory Object or value factory function
         * @returns {undefined} no returns value
         */
        factoryRegister: function(type, factory) {
            var key_parameters = {},
                __type = parse_type(type, key_parameters) .toLowerCase();

            // normalize prop name, remove lead '/'
            for(var prop in key_parameters)
            if (prop[0] === '/') {
                key_parameters[prop.slice(1)] = key_parameters[prop];
                delete key_parameters[prop];
            }

            if (__type.length < type.length || Object.keys(key_parameters).length) {
                // type is subtype with parameters, register to processor.subtypes
                key_parameters.__ctr = factory;
                var subtypes_array = this.subtypes[__type] || (this.subtypes[__type] = []);
                subtypes_array.push(key_parameters);
            } else {
                // register as standalone type
                // check name conflict
                if (this[__type])
                    throw new TypeError('Type ' + type + ' already registered!');

                this[__type] = factory;
            }
        },
    
        /**
         * Register existing parameterized type as a standalone type
         * 
         * @param {string} alias New alias that will be registered, in format namespace.task
         * @param {string} type Existing base type + additional #parameters, in format existingtype#parameters
         * @returns {undefined}
         */
        typeAlias: function(alias, type) {
            var parameters = {},
                __type = parse_type(type, parameters) .toLowerCase(),
                constructor = resolve_ctr(__type, parameters);
            if (!constructor)
                throw new TypeError('Type ' + __type + ' not registered!');

            this[alias.toLowerCase()] = { __type: __type, parameters: parameters, isAlias: true };
        },

        /**
         * Create from parsed parameters and arguments.
         *
         * @param {string} type base type [and parameters].
         * @param {object} parameters Parsed parameters.
         * @param {object} args Parsed arguments.
         * @returns {object} Returns newly created component object.
         */
        createBase: function(type, parameters, args) {

            parameters = parameters || {};
            args = args || {};

            var __type = parse_type(type, parameters, args),
                constructor = resolve_ctr(__type, parameters);

            if (!constructor)
                throw new TypeError('Type ' + __type + ' not registered!');

            for(var prop in parameters)
                if (parameters.hasOwnProperty(prop) && prop[0] === '$')
                    args[prop.substr(1)] = parameters[prop];

            // create object

            var new_control = (constructor.is_constructor) // constructor or factory method ?
                ? new constructor(parameters, args)
                : constructor(parameters, args);

            // reflect after creation if control only
            if (typeof new_control === 'object' && '__type' in new_control)
                new_control.raise('type');

            return new_control;
        },

        /**
         * Create component/call factory function
         *
         * @param {string} type Type and parameters.
         * @param [$prime] Prime value is a responsibility of the component. This parameter value can be of simple type or be derived from DataObject DataArray.
         * @param {object} [args] Arguments hash object to be passed to the component.
         * @param {function} [callback] The callback will be called each time after the creation of a new component.
         * @param {object} [this_arg] The value to be passed as the this parameter to the target function when the callback function is called.
         * @returns {object} Returns newly created component object.
         */
        create: function(type, $prime, args, callback, this_arg) {

            // normalize arguments
            if (typeof $prime === 'function') {
                this_arg = args;
                callback = $prime;
                $prime = undefined;
                args = undefined;
            } else {
                if (typeof $prime === 'object' && !Array.isArray($prime)) {
                    this_arg = callback;
                    callback = args;
                    args = $prime;
                    $prime = undefined;
                }
                if (typeof args === 'function') {
                    this_arg = callback;
                    callback = args;
                    args = undefined;
                }
            }

            var parameters = {};
            if (Array.isArray(args))
                args = {'': args};
            else if (!args)
                args = {};

            var __type = parse_type(type, parameters, args),
                constructor = resolve_ctr(__type, parameters);

            if ($prime !== undefined)
                args['']= $prime;
            
            // load required components
            if (!constructor) {
                var parts = __type.split('.'),
                    mod_path = './modules/' + parts[0] + '/' + parts[1];
                console.log(__type + ' not loaded, try to load ' + mod_path);
                require(mod_path);
                constructor = resolve_ctr(__type, parameters);
            }
            
            if (!constructor)
                throw new TypeError('Type ' + __type + ' not registered!');

            for(var prop in parameters)
                if (parameters.hasOwnProperty(prop) && prop[0] === '$')
                    args[prop.substr(1)] = parameters[prop];

            // create object

            var new_control = (constructor.is_constructor) // constructor or factory method ?
                ? new constructor(parameters, args)
                : constructor(parameters, args);

            // reflect after creation if control only
            if (typeof new_control === 'object' && '__type' in new_control)
                new_control.raise('type');

            return new_control;
        },

        // List of root nodes
        root_nodes: [],

        // Returns newly created component object.

        /**
         * Add newly created named componet(s) as a root node(s). Root nodes are available by name as a property of processor object.
         * Method arguments are the same as in the method of processor.create()
         * @returns {object|Array} Returns newly created component object(s).
         */
        add: function(type) {

            if (Array.isArray(type)) {
                var call_args = Array.prototype.slice(arguments);
                return type.map(function(typ) {
                    call_args[0] = typ;
                    return processor.add.apply(this, call_args);
                }, this);
            }

            var com = type;

            if (typeof type === 'string')
                com = processor.create.apply(this, arguments);

            if (!com.name)
                throw new TypeError('Root node must have name!');

            if (com.name in processor)
                throw new TypeError('Root node named ' + com.name + ' already exist!');

            if (this.root_nodes.indexOf(com) < 0)
                this.root_nodes.push(com);

            return (processor[com.name] = com);
        },

        /**
         * Same as add(), but returns the processor object.
         */
        _add: function() {
            this.add.apply(this, arguments);
            return this;
        },

        /**
         * Remove the specified root node.
         *
         * @param {object|string} com Node object to be removed or root node name.
         * @returns Returns this.
         */
        remove: function(com) {
            var root_nodes = this.root_nodes;
            if (typeof com === 'string') {
                if (com in processor) {
                    var object = processor[com];
                    if (typeof object === 'object' && '__type' in object) {
                        delete processor[name];
                        var index = root_nodes.indexOf(object);
                        if (index >= 0)
                            root_nodes.splice(index, 1);
                    }
                }
            } else {
                var index = root_nodes.indexOf(com),
                    name = com.name;
                if (index >= 0)
                    root_nodes.splice(index, 1);
                if (processor[name] === com)
                    delete processor[name];
            }
            return this;
        },

        /**
         * Check by name and create if not exist named root node component attached to processor library object
         * Method arguments are the same as in the method of processor.create()
         * @returns {object} Returns newly created component object.
         */
        force: function(type, $prime, parameters, args, callback, this_arg) {
            var params = {};
            parse_type(type, params);
            if (!params.name)
                throw new SyntaxError('Invalid node name!');
            return this[params.name] || this.create.apply(this, arguments);
        },

        _force: function(type, /*optional*/ $prime, /*optional*/ args, /*optional*/ callback, /*optional*/ this_arg) {
            this.force.apply(this, arguments);
            return this;
        },

        /**
         * Create a property getter
         *
         * @param {object} object Object
         * @param {string} prop Property name
         * @returns {Function} Returns a function that returns the object property value
         */
        get: function get(object, prop) {
            return function() {
                return object[prop];
            };
        }
    };
    
    // name:namespace.taskname`class classN # parameters / hierarchical parameters @ class parameters
    // parameters format: param=value param2="value with spaces"
    
    /**
     * Parse type string, revision 2.0
     * 
     * @param {string} type Type with parameters, in format name:namespace.control`class1 classN#parameters/inheritable_parameters
     * @param {object} parameters Object acceptor parsed parameters
     * @param {object} attributes Object acceptor parsed attributes ($name, class)
     * @param {boolean} partial_allowed Allowed partial type
     * @returns {String} Base type string
     */
    function parse_type(type, parameters, args, partial_allowed) {

        // determine left part - find separator not in a [known patterns] or "string literals"
        var separator_regex = /[:#\(\),\/`@\s]|$/g,
            name_length = -1,
            __type,
            fixed_params_start = -1,
            fixed_param_start = -1,
            fixed_params_end = -1,
            fixed_params,
            left_part_length = -1,
            known_patterns_regex = /("[\s\S]*?")|(\[[^\[\]\n]*?\]\([^\(\)\n]*?\))/g;

        // iterate separators
        var sresult, kresult;
        while(left_part_length < 0 && (sresult = separator_regex.exec(type))) {

            var pos = sresult.index,
                separator = sresult[0],
                in_pattern = false;

            // check if the separator in any pattern
            do {
                if (kresult && (pos >= kresult.index && pos < known_patterns_regex.lastIndex))
                    in_pattern = true;
            } while(!in_pattern && known_patterns_regex.lastIndex < pos && (kresult = known_patterns_regex.exec(type)))

            if (!in_pattern)
            switch(separator) {
                case ':':
                    if (name_length < 0 && fixed_params_start < 0 && left_part_length < 0)
                        name_length = pos;
                    break;
                case '(':
                    if (fixed_params_end < 0) {
                        fixed_params_start = pos;
                        fixed_param_start = pos + 1;
                        fixed_params = [];
                        __type = type.slice(name_length + 1, pos);
                    }
                    break;
                case ',':
                    if (fixed_params_start >= 0 && fixed_params_end < 0) {
                        // extract from quotes
                        var fpar_value = type.slice(fixed_param_start, pos),
                            qchar = fpar_value[0];
                        fixed_params.push((qchar === '\'' || qchar === '"') ? fpar_value.slice(1,-1) : fpar_value);

                        fixed_param_start = pos + 1;
                    }
                    break;
                case ')':
                    if (fixed_params_start >= 0) {
                        // extract from quotes
                        var fpar_value = type.slice(fixed_param_start, pos),
                            qchar = fpar_value[0];
                        fixed_params.push((qchar === '\'' || qchar === '"') ? fpar_value.slice(1,-1) : fpar_value);

                        fixed_params_end = pos;
                        left_part_length = pos + 1;
                    }
                    break;
                default:
                    left_part_length = pos;
                    if (!__type)
                        __type = type.slice(name_length + 1, pos);
            }
        }

        if (name_length >= 0)
            parameters.name = type.slice(0, name_length);

        if (!__type) {
            if (!partial_allowed)
                throw new TypeError('Type undefined');
        } else if (__type.indexOf('.') < 0)
            __type = 'default.' + __type;

        if (fixed_params)
            parameters['{params}'] = fixed_params;


        // parse parameters
        var pos = left_part_length, paramslen = type.length, class_params = false, inheritable = false, classes = false;
        while(pos < paramslen) {
            switch(type.charAt(pos)) {
                case ' ':
                case '\n':
                case '\t':  // parameters separator
                    pos++;
                    break;
                case '/': // next parameters is inheritable
                    inheritable = true; pos++;
                    break;
                case '@': // next parameters is class parameters
                    class_params = true; pos++;
                    break;
                case '`': // reminder of the line is classes
                    var classes_regex = /`.*?(?=#|`|\/|$|@)/g;
                    classes_regex.lastIndex = pos;
                    var classes = classes_regex.exec(type)[0];
                    parameters.class = classes.slice(1).trim();
                    pos += classes.length;
                    break;
                case '#': // assign identifier
                    var id_regex = /#.*?(?=#|`|\/|\s|$|@)/g;
                    id_regex.lastIndex = pos;
                    var match_id = id_regex.exec(type)[0];
                    parameters.id = match_id.slice(1);
                    pos += match_id.length;
                    break;
                default:
                    var par_name_regex = /\S+?(?=(=|#|`|\/|\s|$|@))/g;
                    par_name_regex.lastIndex = pos;
                    var par_name_match = par_name_regex.exec(type);
                    if (!par_name_match)
                        pos++;
                    else {
                        var parname = par_name_match[0],
                        par_name_after = par_name_match.index + parname.length;
                        if (par_name_match[1] === '=') {
                            if (type.charAt(par_name_after + 1) === '"') {
                                // param="value with spaces"
                                var quotepos = type.indexOf('"', par_name_after + 2);
                                while(quotepos >= 0 && quotepos < paramslen - 1 && ' \n\t#/`'.indexOf(type.charAt(quotepos + 1)) < 0)
                                    quotepos = type.indexOf('"', quotepos + 1);
                                if (quotepos < 0) {
                                    // param=" may be \" and no "
                                    if (inheritable)        parname = '/' + parname;
                                    else if (class_params)  parname = '@' + parname;
                                    parameters[parname] = type.substr(par_name_after + 2);
                                    pos = paramslen;
                                } else {
                                    if (inheritable)        parname = '/' + parname;
                                    else if (class_params)  parname = '@' + parname;
                                    parameters[parname] = type.slice(par_name_after + 2, quotepos);
                                    pos = quotepos + 1;
                                }
                            } else {
                                // param=value
                                var value_regex = /\S*?(?=(#|`|\/|\s|$|@))/g;
                                value_regex.lastIndex = par_name_after + 1;
                                var value = value_regex.exec(type)[0];
                                pos = par_name_after + 1 + value.length;
                                if (inheritable)        parname = '/' + parname;
                                else if (class_params)  parname = '@' + parname;
                                parameters[parname] = value;
                            }
                        } else {
                            // param
                            if (inheritable)        parname = '/' + parname;
                            else if (class_params)  parname = '@' + parname;
                            parameters[parname] = true;
                            pos = par_name_after;
                        }
                    }
            }
        }
    
        // TODO {href} syntax

        return __type;
    }

    function resolve_ctr(__type, parameters) {
        // after parse and before ctr resolve apply alias

        var constructor;
        __type = __type.toLowerCase();

        // map __type -> subtypes array
        if (Object.keys(parameters).length) {
            var subtypes_array = processor.subtypes[__type];
            if (subtypes_array)
            for(var i = 0, c = subtypes_array.length; i < c; i++) { // iterate subtypes array
                // each subtypes array item is key parameters object and contains the constructor reference
                var key_parameters = subtypes_array[i];

                // check for matching all key params values
                var hit = true;

                for(var prop in parameters)
                if (parameters.hasOwnProperty(prop) && prop !== '{params}') {
                    var par_value = parameters[prop];
                    if (prop[0] === '/')
                        prop = prop.slice(1);
                    if ('__ctr,??'.indexOf(prop) < 0
                    && key_parameters[prop] !== par_value) {
                        hit = false;
                        break;
                    }
                }

                if (hit) {
                    constructor = key_parameters.__ctr;
                    break;
                }
            }
        }

        if (!constructor) {
            constructor = processor[__type];

            // apply if alias
            if (constructor && constructor.isAlias && constructor.__type !== __type) {
                // apply alias parameters
                var alias_parameters = constructor.parameters;
                for(var prop in alias_parameters)
                    if (alias_parameters.hasOwnProperty(prop))
                        parameters[prop] = alias_parameters[prop];

                constructor = resolve_ctr(constructor.__type, parameters);
            }
        }

        return constructor;
    }
    processor.resolveType = resolve_ctr;
    
    function setParent(value, index) {
        var parent = this._parent;
        if (value !== parent) {
            this._parent = value;
            var name = this._name;

            if (parent) {
                var parent_childs = parent.childs,
                    index = parent_childs.indexOf(this);
                if (index >= 0)
                    parent_childs.splice(index, 1);

                if (name && parent.hasOwnProperty(name) && parent[name] === this)
                    delete parent[name];
            }

            if (value) {
                var value_childs = value.childs;

// profiling: very expensive operation
//                    var index = value_childs.indexOf(this);
//                    if (index >= 0)
//                        parent_childs.splice(index, 1);

                if (index === undefined)
                    value_childs.push(this);
                else
                    value_childs.splice(index, 0, this);

                if (name)
                    value[name] = this;
            }

            this.raise('parent', value);
        }
    }

    // Nodes tree activation
    setInterval(function() {
        var stack = [], com;
        for(var i = 0, c = processor.root_nodes.length; i < c; i++)
            stack.push(processor.root_nodes[i]);

        while(com = stack.pop()) {
            var childs = com.childs,
                atimer_interval = com.activate_timer_interval,
                atimer_error = com.activate_timer_error;
            if (atimer_interval && !atimer_error) {
                var atimer = com.activate_timer--;
                if (atimer <= 0) {
                    try {
                        com.raise('activate');
                    } catch (e) {
                        // on exception stop timer execution
                        com.activate_timer_error = e;
                    }
                    com.activate_timer = com.activate_timer_interval;
                }
            }
            for(var i = 0, c = childs.length; i < c; i++)
                stack.push(childs[i]);
        }
    }, 100);


    var IDENTIFIERS = ',__type,add,_add,arguments,class,controls,data,delete,each,element,findFirst,findLast,first,forEach,id,insert,_insert,last,length,name,parameters,parent,style,';
    // Com prototype
    var node_common = {

        /**
         * Raise event
         *
         * @param {string} event Event identifier.
         * @param Arbitrary number of arguments to be passed to handlers.
         * @returns {object} Component this.
         */
        raise: function(event) {
            var args = Array.prototype.slice.call(arguments);
            (this.emitter || (this.emitter = new emitter())).emit.apply(this, args);
        },

        /**
         * Add event listener
         *
         * @param {string} event Event identifier.
         * @param {function} callback Callback function to be called when the event is raised. Arguments of raise() will be passed to the callback.
         * @returns {object} Component this.
         */
        on: function(event, callback) {
//            if (this instanceof FSObject) {
//                if (event === 'watcher') {
//                    this.__watch_listeners = this.__watch_listeners || 0 + 1;
//                    this.setWatcher();
//                } else if (event === 'fileWatcher') {
//                    this.__watch_file_listeners = this.__watch_file_listeners || 0 + 1;
//                    this.setFileWatcher();
//                }
//            }
            var args = Array.prototype.slice.call(arguments);
            (this.emitter || (this.emitter = new emitter())).on.apply(this, args);
            return this;
        },

        /**
         * Remove event listener
         *
         * @param {string} event Event identifier.
         * @param {function} callback Callback function to be removed.
         * @returns {object} Component this.
         */
        removeListener: function(event, callback) {
//            if (this instanceof FSObject) {
//                if (event === 'watcher') {
//                    if (--this.__watch_listeners <= 0)
//                        this.removeWatcher();
//                } else if (event === 'fileWatcher') {
//                    if (--this.__watch_file_listeners <= 0)
//                        this.removeFileWatcher();
//                }
//            }
            var args = Array.prototype.slice.call(arguments);
            (this.emitter || (this.emitter = new emitter())).on.apply(this, args);
        },

        /**
         * Component initialization. Initialize component attributes ```parameters, arguments, parent, childs``` etc. Normally called from the constructor function of the component.
         *
         * @param {string} __type Base type of the component. This value is assigned to the attribute __type of the component.
         * @param {object} parameters Hash object contains parsed parameters of the component.
         * @param {object} args Hash object contains arguments of the component.
         * @returns {object} Returns this.
         */
        initialize: function(__type, parameters, args) {
            return processor.componentInitialize(this, __type, parameters, args);
        },

        /**
         * Get or set parameter value.
         *
         * @param {string} name Parameter name.
         * @param [value] value Parameter value.
         * @returns Returns parameter value or this.
         */
        parameter: function(name, value) {
            var parameters = this.parameters;

            if (arguments.length < 1)
                return parameters[name] || parameters['/' + name];

            if (value !== parameters[name]) {
                parameters[name] = value;
            }
        },

        /**
         * Set parameter value and return this.
         *
         * @param {string} name Parameter name.
         * @param [value] value Parameter value.
         * @returns Returns this.
         */
        _parameter: function(name, value) {
            this.parameter(name, value);
            return this;
        },

        /**
         * Create a new component and insert to the component.childs collection at the specified index.
         *
         * @param {number} index Index in .childs collection.
         * @param {string} type Type and parameters.
         * @param [$prime] Prime value is a responsibility of the component. This parameter value can be of simple type or be derived from DataObject DataArray.
         * @param {object} [args] Arguments hash object to be passed to the component.
         * @param {function} [callback] The callback will be called each time after the creation of a new component.
         * @param {object} [this_arg] The value to be passed as the this parameter to the target function when the callback function is called.
         * @returns {object} Returns newly created component object.
         */
        insert: function(index, type, /*optional*/ $prime, /*optional*/ args, /*optional*/ callback, /*optional*/ this_arg) {

            if (!type)
                return;

            // normalize arguments
            if (typeof $prime === 'function') {
                this_arg = args;
                callback = $prime;
                $prime = undefined;
                args = undefined;
            } else {
                if (typeof $prime === 'object' && !Array.isArray($prime)) {
                    this_arg = callback;
                    callback = args;
                    args = $prime;
                    $prime = undefined;
                }
                if (typeof args === 'function') {
                    this_arg = callback;
                    callback = args;
                    args = undefined;
                }
            }

            if (Array.isArray(type)) {
                // collection detected
                var result;
                for(var i = index, c = index + type.length; i < c; i++)
                    result = this.insert(i, type[i], $prime, args, callback, this_arg);
                return result;
            }
            
            if (typeof type === 'object') {
                // it is a control?
                var add_task = type;
                if (add_task.hasOwnProperty('__type'))
                    setParent.call(type, this, index);
                return add_task;
            }

            if (Array.isArray(args))
                args = {'': args};
            else if (!args)
                args = {};
            var parameters = {};
            
            // transfer inheritable parameters to the created object
            var this_parameters = this.parameters;
            for(var prop in this_parameters)
                if (this_parameters.hasOwnProperty(prop) && prop[0] === '/')
                    parameters[prop] = this_parameters[prop];
            
            // resolve constructor
            var __type = parse_type(type, parameters, args),
                constructor = resolve_ctr(__type, parameters);
            
            if ($prime !== undefined)
                args[''] = $prime;
            
            // load required components
            if (!constructor) {
                var parts = __type.split('.'),
                    mod_path = './modules/' + parts[0] + '/' + parts[1];
                console.log(__type + ' not loaded, try to load ' + mod_path);
                require(mod_path);
                constructor = resolve_ctr(__type, parameters);
            }
            
            if (!constructor)
                throw new TypeError('Type ' + __type + ' not registered!');
            
            // move $parameters to attributes (unsafe)
            for(var prop in parameters)
                if (parameters.hasOwnProperty(prop) && prop[0] === '$')
                    args[prop.substr(1)] = parameters[prop];
            
            // create control

            var new_control = new constructor(parameters, args);

            // reflect after creation
            new_control.raise('type');

            // set parent property
            setParent.call(new_control, this, index);

            // callback
            if (callback)
                callback.call(this_arg || this, new_control);

            return new_control;
        },

        // Returns newly created component object.
        add: function(type, /*optional*/ $prime, /*optional*/ args, /*optional*/ callback, /*optional*/ this_arg) {
            return this.insert(this.childs.length, type, $prime, args, callback, this_arg);
        },

        _add: function(type, /*optional*/ $prime, /*optional*/ args, /*optional*/ callback, /*optional*/ this_arg) {
            this.insert(this.childs.length, type, $prime, args, callback, this_arg);
            return this;
        },

        /**
         * Check by name and create if not exist child component
         * Method arguments are the same as in the method of create()
         * @returns {object} Returns newly created component object.
         */
        force: function(type, /*optional*/ $prime, /*optional*/ args, /*optional*/ callback, /*optional*/ this_arg) {
            var params = {};
            parse_type(type, params);
            if (!params.name)
                throw new SyntaxError('Invalid node name!');
            return this[params.name] || this.add.apply(this, arguments);
        },

        _force: function(type, /*optional*/ $prime, /*optional*/ args, /*optional*/ callback, /*optional*/ this_arg) {
            this.force.apply(this, arguments);
            return this;
        },

        bulk: function(type, $prime, args, list, callback, this_arg) {

            // normalize arguments
            if (!Array.isArray(list)) {
                if (Array.isArray(args)) {
                    this_arg = callback;
                    callback = list;
                    list = args;
                    if (typeof $prime === 'object' && !Array.isArray($prime)) {
                        args = $prime;
                        $prime = undefined;
                    } else
                        args = undefined;
                } else if (Array.isArray($prime)) {
                    this_arg = list;
                    callback = args;
                    list = $prime;
                    args = undefined;
                    $prime = undefined;
                }
                if (typeof list === 'function') {
                    this_arg = callback;
                    callback = list;
                } else if (typeof args === 'function') {
                    this_arg = list;
                    callback = args;
                } else if (typeof $prime === 'function') {
                    this_arg = args;
                    callback = $prime;
                }
            }

            for(var i = 0, c = list.length; i < c; i++) {
                var item_type = list[i],
                    item_parameters = {},
                    item_arguments = {},
                    __type;

                if (type)
                    __type = parse_type(type, item_parameters, item_arguments, true);
                if (item_type) {
                    __type = parse_type(item_type, item_parameters, item_arguments, true) || __type;
                }

                var control = processor.createBase(__type, item_parameters, item_arguments);
                this.add(control);
            }
        },

        _bulk: function(type, $prime, args, callback, this_arg) {
            this.bulk.apply(this, arguments);
            return this;
        },

        changed: function() {
            this.state++;
        },

        // ??
        removePrime: function(args) {
            var args = (arguments.length) ? args : this.arguments;
            if (args && '' in args) {
                var prime = args[''];
                delete args[''];
                return prime;
            }
        },

        splitParams: function(paramstr) {
            if (!arguments.length)
                paramstr = this.parameters['{params}'];
            var result = [];
            while (paramstr) {
                var paramslen = paramstr.length;
                if (paramstr[0] === '"') {
                    // ("value with spaces" ...
                    var quotepos = paramstr.indexOf('"', 1);
                    while(quotepos >= 0 && quotepos < paramslen - 1 && ' \n\t,)'.indexOf(paramstr.charAt(quotepos + 1)) < 0)
                        quotepos = paramstr.indexOf('"', quotepos + 1);
                    if (quotepos < 0) {
                        // param=" may be \" and no "
                        result.push(paramstr.substr(1));
                        paramstr = undefined;
                    } else {
                        result.push(paramstr.slice(1, quotepos));
                        paramstr = paramstr.slice(quotepos + 1);
                    }
                } else {
                    var commapos = paramstr.indexOf(',');
                    if (commapos < 0) {
                        result.push(paramstr);
                        paramstr = undefined;
                    } else {
                        result.push(paramstr.slice(0, commapos));
                        paramstr = paramstr.slice(commapos + 1);
                    }
                }
            }
            if (result.length)
                return result;
        },

        toString: function() {
            var result = this.__type;
            var childs_len = this.childs.length;
            if (childs_len)
                result += ' childs:' + childs_len;
            return result;
        },

        // name of the control
        get name() { return this._name; },
        set name(value) {
            if (IDENTIFIERS.indexOf(',' + value + ',') >= 0)
                throw new SyntaxError('Invalid node name "' + value + '"!');

            var name = this._name;
            if (value !== name) {
                this._name = value;

                var parent = this._parent;
                if (parent) {
                    if (name && parent.hasOwnProperty(name) && parent[name] === this)
                        delete parent[name];

                    if (value)
                        parent[value] = this;
                }
            }
        },

        // parent property
        get parent() { return this._parent; },
        set parent(value) { setParent.call(this, value); },

        // length property
        get length() { return this.childs.length; },
        set length(value) { this.childs.length = value; }
    };

    function ComPrototype() {
    };
    ComPrototype.prototype = node_common;
    // deprecated
    processor.node_prototype = ComPrototype;
    processor.com_prototype = ComPrototype;

    processor.splitParams = node_common.splitParams;
    
    // builtin components
    
    function Container(parameters, args) {
        this.initialize('container', parameters, args);
    }
    Container.prototype = new ComPrototype();
    processor.typeRegister('container', Container);
//    processor.typeRegister('[]', Container);
    
    function DataObject(parameters, args) {
        this.initialize('default.dataobject', parameters, args);
    }
    DataObject.prototype = new ComPrototype();
    processor.typeRegister('dataobject', DataObject);
    
    function DataArray(parameters, args) {
        this.initialize('default.dataobject', parameters, args);
    }
    DataArray.prototype = new ComPrototype();
    processor.typeRegister('default.dataarray', DataArray);



    // Default root nodes - default activated containers
    // * fs - file system objects tree
    // * root - default parent/child hierarchy
    processor.add(['fs:container', 'root:container', 'watchers:container']);

// exports
if (typeof module !== 'undefined' && module.exports) module.exports = processor;
if (typeof define === 'function' && define.amd) define(processor);
})();